//! AOT (Ahead-of-Time) Template Compiler
//! Phase 7 optimization: Compile Jinja templates to native Zig code at build time
//!
//! This generates Zig source files that can be @imported and called directly,
//! eliminating all runtime parsing, bytecode interpretation, and allocation overhead.
//!
//! Usage:
//!   const aot = @import("aot_compiler.zig");
//!   const code = try aot.compileToZig(allocator, "Hello {{ name }}!", "hello");
//!   // code contains Zig source that can be written to a file
//!
//! Generated code looks like:
//!   pub fn render(ctx: anytype, writer: anytype) !void {
//!       try writer.writeAll("Hello ");
//!       try writer.writeAll(ctx.get("name") orelse "");
//!       try writer.writeAll("!");
//!   }

const std = @import("std");
const parser = @import("parser.zig");
const nodes = @import("nodes.zig");
const lexer = @import("lexer.zig");
const environment = @import("environment.zig");

/// AOT Compiler - generates Zig source code from Jinja templates
pub const AotCompiler = struct {
    allocator: std.mem.Allocator,
    output: std.ArrayList(u8),
    indent_level: usize,
    loop_depth: usize,
    temp_var_counter: usize,
    /// Track declared local variables for scoping
    local_vars: std.StringHashMap(void),

    const Self = @This();

    /// Error type for AOT compilation - explicit to support recursion
    pub const Error = error{OutOfMemory};

    pub fn init(allocator: std.mem.Allocator) Self {
        return .{
            .allocator = allocator,
            .output = std.ArrayList(u8).empty,
            .indent_level = 0,
            .loop_depth = 0,
            .temp_var_counter = 0,
            .local_vars = std.StringHashMap(void).init(allocator),
        };
    }

    pub fn deinit(self: *Self) void {
        self.output.deinit(self.allocator);
        self.local_vars.deinit();
    }

    /// Compile a template source to Zig code
    pub fn compile(self: *Self, source: []const u8, template_name: []const u8) ![]const u8 {
        // Create a temporary environment for parsing
        var env = environment.Environment.init(self.allocator);
        defer env.deinit();

        // Parse the template
        var lex = lexer.Lexer.init(&env, source, template_name);
        const stream = try lex.tokenize(self.allocator);
        defer self.allocator.free(stream.tokens);

        var psr = parser.Parser.init(&env, stream, template_name, self.allocator);
        const template = try psr.parse();
        defer template.deinit(self.allocator);

        // Generate Zig header
        try self.writeHeader(template_name);

        // Generate render function
        try self.writeRenderFn(template);

        // Generate footer
        try self.writeFooter();

        return try self.output.toOwnedSlice(self.allocator);
    }

    fn writeHeader(self: *Self, template_name: []const u8) !void {
        try self.write("//! Auto-generated from template: ");
        try self.write(template_name);
        try self.write("\n");
        try self.write("//! Generated by vibe-jinja AOT compiler\n");
        try self.write("//! DO NOT EDIT - regenerate from source template\n\n");
        try self.write("const std = @import(\"std\");\n\n");
    }

    fn writeRenderFn(self: *Self, template: *nodes.Template) !void {
        try self.write("/// Render the template with the given context\n");
        try self.write("/// Context must have:\n");
        try self.write("///   - get(name: []const u8) ?[]const u8\n");
        try self.write("///   - getInt(name: []const u8) ?i64 (for numbers)\n");
        try self.write("///   - getList(name: []const u8) ?[][]const u8 (for loops)\n");
        try self.write("///   - getAttr(obj: []const u8, attr: []const u8) ?[]const u8 (for attribute access)\n");
        try self.write("pub fn render(ctx: anytype, writer: anytype) !void {\n");
        self.indent_level = 1;

        // Generate body
        for (template.body.items) |stmt| {
            try self.generateStatement(stmt);
        }

        self.indent_level = 0;
        try self.write("}\n");
    }

    fn writeFooter(self: *Self) !void {
        try self.write("\n/// Render to a string (allocates)\n");
        try self.write("pub fn renderToString(ctx: anytype, allocator: std.mem.Allocator) ![]u8 {\n");
        try self.write("    var output = std.ArrayList(u8).init(allocator);\n");
        try self.write("    errdefer output.deinit();\n");
        try self.write("    try render(ctx, output.writer());\n");
        try self.write("    return output.toOwnedSlice();\n");
        try self.write("}\n");
    }

    fn generateStatement(self: *Self, stmt: *nodes.Stmt) Error!void {
        switch (stmt.tag) {
            .output => {
                const output: *nodes.Output = @ptrCast(@alignCast(stmt));
                // Output plain text content
                if (output.content.len > 0) {
                    try self.writeIndent();
                    try self.write("try writer.writeAll(\"");
                    try self.writeEscapedString(output.content);
                    try self.write("\");\n");
                }
                // Output expressions
                for (output.nodes.items) |expr| {
                    try self.generateOutput(expr);
                }
            },
            .for_loop => {
                const for_stmt: *nodes.For = @ptrCast(@alignCast(stmt));
                try self.generateFor(for_stmt);
            },
            .if_stmt => {
                const if_stmt: *nodes.If = @ptrCast(@alignCast(stmt));
                try self.generateIf(if_stmt);
            },
            .set => {
                const set_stmt: *nodes.Set = @ptrCast(@alignCast(stmt));
                try self.generateSet(set_stmt);
            },
            .with => {
                const with_stmt: *nodes.With = @ptrCast(@alignCast(stmt));
                try self.generateWith(with_stmt);
            },
            .filter_block => {
                const filter_stmt: *nodes.FilterBlock = @ptrCast(@alignCast(stmt));
                try self.generateFilterBlock(filter_stmt);
            },
            .comment => {
                // Comments are ignored in output
            },
            .continue_stmt => {
                try self.writeIndent();
                try self.write("continue;\n");
            },
            .break_stmt => {
                try self.writeIndent();
                try self.write("break;\n");
            },
            .expr_stmt => {
                // Expression statement ({% do expr %}) - evaluate but don't output
                try self.writeIndent();
                try self.write("// Expression statement (do)\n");
            },
            .debug_stmt => {
                try self.writeIndent();
                try self.write("// Debug statement - context info would be printed at runtime\n");
            },
            .block, .extends, .include, .import, .from_import, .macro, .call, .call_block, .autoescape => {
                try self.writeIndent();
                try self.write("// Note: ");
                try self.write(@tagName(stmt.tag));
                try self.write(" requires runtime support\n");
            },
        }
    }

    /// Generate set statement ({% set var = value %} or {% set var %}...{% endset %})
    fn generateSet(self: *Self, set_stmt: *nodes.Set) Error!void {
        try self.writeIndent();

        // Check if this is a block set or simple set
        if (set_stmt.body) |body| {
            // Block set: {% set var %}content{% endset %}
            // Generate code that captures rendered content
            try self.write("{\n");
            self.indent_level += 1;

            try self.writeIndent();
            try self.write("var _set_buf = std.ArrayList(u8).init(ctx.allocator);\n");
            try self.writeIndent();
            try self.write("defer _set_buf.deinit();\n");
            try self.writeIndent();
            try self.write("const _set_writer = _set_buf.writer();\n");

            // Generate body statements writing to _set_writer
            for (body.items) |stmt| {
                // We need to generate output to _set_writer instead of writer
                // For now, generate a comment noting this
                try self.writeIndent();
                try self.write("// Block content for '");
                try self.write(set_stmt.name);
                try self.write("'\n");
                try self.generateStatement(stmt);
            }

            try self.writeIndent();
            try self.write("const _set_");
            try self.write(set_stmt.name);
            try self.write(" = _set_buf.toOwnedSlice() catch \"\";\n");
            try self.writeIndent();
            try self.write("_ = _set_");
            try self.write(set_stmt.name);
            try self.write("; // Variable available as _set_");
            try self.write(set_stmt.name);
            try self.write("\n");

            self.indent_level -= 1;
            try self.writeIndent();
            try self.write("}\n");
        } else {
            // Simple set: {% set var = expr %}
            try self.write("const _set_");
            try self.write(set_stmt.name);
            try self.write(" = ");
            try self.generateExpressionValue(set_stmt.value);
            try self.write(";\n");
            try self.writeIndent();
            try self.write("_ = _set_");
            try self.write(set_stmt.name);
            try self.write("; // Variable '");
            try self.write(set_stmt.name);
            try self.write("' set\n");
        }
    }

    /// Generate with statement ({% with x = 1, y = 2 %}...{% endwith %})
    fn generateWith(self: *Self, with_stmt: *nodes.With) Error!void {
        try self.writeIndent();
        try self.write("{ // with scope\n");
        self.indent_level += 1;

        // Generate local variable declarations from targets/values arrays
        for (with_stmt.targets.items, 0..) |target, i| {
            if (i < with_stmt.values.items.len) {
                try self.writeIndent();
                try self.write("const _with_");
                try self.write(target);
                try self.write(" = ");
                try self.generateExpressionValue(with_stmt.values.items[i]);
                try self.write(";\n");
                try self.writeIndent();
                try self.write("_ = _with_");
                try self.write(target);
                try self.write(";\n");
            }
        }

        // Generate body
        for (with_stmt.body.items) |stmt| {
            try self.generateStatement(stmt);
        }

        self.indent_level -= 1;
        try self.writeIndent();
        try self.write("} // end with\n");
    }

    /// Generate filter block ({% filter upper %}...{% endfilter %})
    fn generateFilterBlock(self: *Self, filter_stmt: *nodes.FilterBlock) Error!void {
        const temp_var = self.temp_var_counter;
        self.temp_var_counter += 1;

        // Get filter name from filter expression
        const filter_name: []const u8 = if (filter_stmt.filter_expr == .filter)
            filter_stmt.filter_expr.filter.name
        else if (filter_stmt.filter_expr == .name)
            filter_stmt.filter_expr.name.name
        else
            "unknown";

        try self.writeIndent();
        try self.write("{ // filter block: ");
        try self.write(filter_name);
        try self.write("\n");
        self.indent_level += 1;

        try self.writeIndent();
        try self.write("var _filter_buf");
        try self.writeFmt("{d}", .{temp_var});
        try self.write(" = std.ArrayList(u8).init(ctx.allocator);\n");
        try self.writeIndent();
        try self.write("defer _filter_buf");
        try self.writeFmt("{d}", .{temp_var});
        try self.write(".deinit();\n");

        // Generate body (would write to filter buffer)
        for (filter_stmt.body.items) |stmt| {
            try self.generateStatement(stmt);
        }

        // Apply filter to captured content
        try self.writeIndent();
        try self.write("const _filtered");
        try self.writeFmt("{d}", .{temp_var});
        try self.write(" = _filter_buf");
        try self.writeFmt("{d}", .{temp_var});
        try self.write(".items;\n");

        // Apply the filter
        try self.writeIndent();
        if (std.mem.eql(u8, filter_name, "upper")) {
            try self.write("for (_filtered");
            try self.writeFmt("{d}", .{temp_var});
            try self.write(") |c| try writer.writeByte(std.ascii.toUpper(c));\n");
        } else if (std.mem.eql(u8, filter_name, "lower")) {
            try self.write("for (_filtered");
            try self.writeFmt("{d}", .{temp_var});
            try self.write(") |c| try writer.writeByte(std.ascii.toLower(c));\n");
        } else {
            try self.write("try writer.writeAll(_filtered");
            try self.writeFmt("{d}", .{temp_var});
            try self.write(");\n");
        }

        self.indent_level -= 1;
        try self.writeIndent();
        try self.write("} // end filter block\n");
    }

    fn generateOutput(self: *Self, expr: nodes.Expression) Error!void {
        try self.writeIndent();

        switch (expr) {
            .string_literal => |lit| {
                try self.write("try writer.writeAll(\"");
                try self.writeEscapedString(lit.value);
                try self.write("\");\n");
            },
            .integer_literal => |lit| {
                try self.write("try writer.print(\"{d}\", .{");
                try self.writeFmt("{d}", .{lit.value});
                try self.write("});\n");
            },
            .float_literal => |lit| {
                try self.write("try writer.print(\"{d}\", .{");
                try self.writeFmt("{d}", .{lit.value});
                try self.write("});\n");
            },
            .boolean_literal => |lit| {
                try self.write("try writer.writeAll(\"");
                try self.write(if (lit.value) "true" else "false");
                try self.write("\");\n");
            },
            .null_literal => {
                try self.write("// null literal - no output\n");
            },
            .name => |name| {
                try self.write("if (ctx.get(\"");
                try self.write(name.name);
                try self.write("\")) |v| try writer.writeAll(v);\n");
            },
            .filter => |filter| {
                try self.generateFilterOutput(filter);
            },
            .getattr => |attr| {
                try self.generateGetAttrOutput(attr);
            },
            .bin_expr => |bin| {
                try self.generateBinExprOutput(bin);
            },
            .unary_expr => |unary| {
                try self.generateUnaryExprOutput(unary);
            },
            .cond_expr => |cond| {
                try self.generateCondExprOutput(cond);
            },
            .call_expr => |call| {
                try self.generateCallExprOutput(call);
            },
            .concat => |concat| {
                try self.generateConcatOutput(concat);
            },
            .list_literal => |list| {
                try self.write("try writer.writeAll(\"[\");\n");
                for (list.elements.items, 0..) |elem, i| {
                    if (i > 0) {
                        try self.writeIndent();
                        try self.write("try writer.writeAll(\", \");\n");
                    }
                    try self.generateOutput(elem);
                }
                try self.writeIndent();
                try self.write("try writer.writeAll(\"]\");\n");
            },
            .getitem => |item| {
                try self.generateGetItemOutput(item);
            },
            else => {
                try self.write("// Unsupported expression type: ");
                try self.write(@tagName(expr));
                try self.write("\n");
            },
        }
    }

    /// Generate binary expression output (a + b, a - b, etc.)
    fn generateBinExprOutput(self: *Self, bin: *nodes.BinExpr) Error!void {
        const temp_var = self.temp_var_counter;
        self.temp_var_counter += 1;

        try self.write("{\n");
        self.indent_level += 1;

        // Evaluate left operand
        try self.writeIndent();
        try self.write("const _left");
        try self.writeFmt("{d}", .{temp_var});
        try self.write(" = ");
        try self.generateExpressionValue(bin.left);
        try self.write(";\n");

        // Evaluate right operand
        try self.writeIndent();
        try self.write("const _right");
        try self.writeFmt("{d}", .{temp_var});
        try self.write(" = ");
        try self.generateExpressionValue(bin.right);
        try self.write(";\n");

        // Apply operation and output
        try self.writeIndent();
        try self.write("const _result");
        try self.writeFmt("{d}", .{temp_var});
        try self.write(" = _left");
        try self.writeFmt("{d}", .{temp_var});

        switch (bin.op) {
            .ADD => try self.write(" + "),
            .SUB => try self.write(" - "),
            .MUL => try self.write(" * "),
            .DIV => try self.write(" / "),
            .MOD => try self.write(" % "),
            .FLOORDIV => try self.write(" / "), // Integer division in Zig
            .POW => {
                // Power operation - use std.math.pow
                try self.write(";\n");
                try self.writeIndent();
                try self.write("const _result");
                try self.writeFmt("{d}", .{temp_var});
                try self.write(" = std.math.pow(i64, _left");
                try self.writeFmt("{d}", .{temp_var});
                try self.write(", @intCast(_right");
                try self.writeFmt("{d}", .{temp_var});
                try self.write("))");
            },
            else => try self.write(" ??? "),
        }

        if (bin.op != .POW) {
            try self.write("_right");
            try self.writeFmt("{d}", .{temp_var});
        }
        try self.write(";\n");

        try self.writeIndent();
        try self.write("try writer.print(\"{d}\", .{_result");
        try self.writeFmt("{d}", .{temp_var});
        try self.write("});\n");

        self.indent_level -= 1;
        try self.writeIndent();
        try self.write("}\n");
    }

    /// Generate unary expression output (-x, not x)
    fn generateUnaryExprOutput(self: *Self, unary: *nodes.UnaryExpr) Error!void {
        const temp_var = self.temp_var_counter;
        self.temp_var_counter += 1;

        try self.write("{\n");
        self.indent_level += 1;

        try self.writeIndent();
        try self.write("const _operand");
        try self.writeFmt("{d}", .{temp_var});
        try self.write(" = ");
        try self.generateExpressionValue(unary.node);
        try self.write(";\n");

        try self.writeIndent();
        switch (unary.op) {
            .SUB => {
                try self.write("try writer.print(\"{d}\", .{-_operand");
                try self.writeFmt("{d}", .{temp_var});
                try self.write("});\n");
            },
            .NOT => {
                try self.write("try writer.writeAll(if (!_operand");
                try self.writeFmt("{d}", .{temp_var});
                try self.write(") \"true\" else \"false\");\n");
            },
            .ADD => {
                try self.write("try writer.print(\"{d}\", .{_operand");
                try self.writeFmt("{d}", .{temp_var});
                try self.write("});\n");
            },
            else => {
                try self.write("// Unsupported unary operator\n");
            },
        }

        self.indent_level -= 1;
        try self.writeIndent();
        try self.write("}\n");
    }

    /// Generate conditional expression output (a if b else c)
    fn generateCondExprOutput(self: *Self, cond: *nodes.CondExpr) Error!void {
        try self.write("if (");
        try self.generateCondition(cond.condition);
        try self.write(") {\n");

        self.indent_level += 1;
        try self.generateOutput(cond.true_expr);
        self.indent_level -= 1;

        try self.writeIndent();
        try self.write("} else {\n");

        self.indent_level += 1;
        try self.generateOutput(cond.false_expr);
        self.indent_level -= 1;

        try self.writeIndent();
        try self.write("}\n");
    }

    /// Generate function call expression output
    fn generateCallExprOutput(self: *Self, call: *nodes.CallExpr) Error!void {
        // Get function name
        const func_name = switch (call.func) {
            .name => |n| n.name,
            else => "unknown",
        };

        // Handle built-in functions
        if (std.mem.eql(u8, func_name, "range")) {
            try self.write("// range() call - generates sequence\n");
            try self.writeIndent();
            try self.write("// Arguments would be evaluated at runtime\n");
        } else if (std.mem.eql(u8, func_name, "dict")) {
            try self.write("// dict() call - creates dictionary\n");
        } else if (std.mem.eql(u8, func_name, "lipsum")) {
            try self.write("// lipsum() call - generates lorem ipsum\n");
        } else {
            try self.write("// Function call: ");
            try self.write(func_name);
            try self.write("()\n");
        }
    }

    /// Generate concatenation output (a ~ b)
    fn generateConcatOutput(self: *Self, concat: *nodes.Concat) Error!void {
        for (concat.nodes.items) |node| {
            try self.generateOutput(node);
        }
    }

    /// Generate getitem output (obj[key])
    fn generateGetItemOutput(self: *Self, item: *nodes.Getitem) Error!void {
        // Get object name
        const obj_name = switch (item.node) {
            .name => |n| n.name,
            else => null,
        };

        if (obj_name) |name| {
            try self.write("if (ctx.getItem(\"");
            try self.write(name);
            try self.write("\", ");

            // Generate key (using 'arg' field)
            switch (item.arg) {
                .integer_literal => |lit| {
                    try self.writeFmt("{d}", .{lit.value});
                },
                .string_literal => |lit| {
                    try self.write("\"");
                    try self.writeEscapedString(lit.value);
                    try self.write("\"");
                },
                else => {
                    try self.write("0");
                },
            }
            try self.write(")) |v| try writer.writeAll(v);\n");
        } else {
            try self.write("// Complex getitem expression\n");
        }
    }

    /// Generate expression as a value (for assignments)
    fn generateExpressionValue(self: *Self, expr: nodes.Expression) Error!void {
        switch (expr) {
            .string_literal => |lit| {
                try self.write("\"");
                try self.writeEscapedString(lit.value);
                try self.write("\"");
            },
            .integer_literal => |lit| {
                try self.writeFmt("{d}", .{lit.value});
            },
            .float_literal => |lit| {
                try self.writeFmt("{d}", .{lit.value});
            },
            .boolean_literal => |lit| {
                try self.write(if (lit.value) "true" else "false");
            },
            .null_literal => {
                try self.write("null");
            },
            .name => |name| {
                try self.write("ctx.get(\"");
                try self.write(name.name);
                try self.write("\") orelse \"\"");
            },
            .bin_expr => |bin| {
                try self.write("(");
                try self.generateExpressionValue(bin.left);
                switch (bin.op) {
                    .ADD => try self.write(" + "),
                    .SUB => try self.write(" - "),
                    .MUL => try self.write(" * "),
                    .DIV => try self.write(" / "),
                    .MOD => try self.write(" % "),
                    else => try self.write(" ??? "),
                }
                try self.generateExpressionValue(bin.right);
                try self.write(")");
            },
            .unary_expr => |unary| {
                switch (unary.op) {
                    .SUB => try self.write("-"),
                    .NOT => try self.write("!"),
                    .ADD => try self.write("+"),
                    else => {},
                }
                try self.generateExpressionValue(unary.node);
            },
            .cond_expr => |cond| {
                try self.write("if (");
                try self.generateCondition(cond.condition);
                try self.write(") ");
                try self.generateExpressionValue(cond.true_expr);
                try self.write(" else ");
                try self.generateExpressionValue(cond.false_expr);
            },
            else => {
                try self.write("@as(i64, 0) // Complex expression");
            },
        }
    }

    fn generateFilterOutput(self: *Self, filter: *nodes.FilterExpr) Error!void {
        // Generate temp var for filter chain
        const temp_var = self.temp_var_counter;
        self.temp_var_counter += 1;

        // Handle filter chains (value | filter1 | filter2)
        if (filter.node == .filter) {
            // This is a chained filter - process recursively
            try self.generateFilterChain(filter, temp_var);
            return;
        }

        // For simple filters on variables
        if (filter.node == .name) {
            const name = filter.node.name;
            try self.write("{\n");
            self.indent_level += 1;
            try self.writeIndent();
            try self.write("const _tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write(" = ctx.get(\"");
            try self.write(name.name);
            try self.write("\") orelse \"\";\n");

            // Apply filter
            try self.writeIndent();
            try self.applyFilter(filter.name, temp_var, filter.args);

            self.indent_level -= 1;
            try self.writeIndent();
            try self.write("}\n");
        } else if (filter.node == .string_literal) {
            // Filter on string literal
            const lit = filter.node.string_literal;
            try self.write("{\n");
            self.indent_level += 1;
            try self.writeIndent();
            try self.write("const _tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write(" = \"");
            try self.writeEscapedString(lit.value);
            try self.write("\";\n");

            try self.writeIndent();
            try self.applyFilter(filter.name, temp_var, filter.args);

            self.indent_level -= 1;
            try self.writeIndent();
            try self.write("}\n");
        } else if (filter.node == .integer_literal) {
            // Filter on integer literal
            const lit = filter.node.integer_literal;
            try self.write("{\n");
            self.indent_level += 1;
            try self.writeIndent();
            try self.write("const _tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write(" = ");
            try self.writeFmt("{d}", .{lit.value});
            try self.write(";\n");

            try self.writeIndent();
            try self.applyFilterNumeric(filter.name, temp_var);

            self.indent_level -= 1;
            try self.writeIndent();
            try self.write("}\n");
        } else {
            // Complex expression as filter input
            try self.write("{\n");
            self.indent_level += 1;

            try self.writeIndent();
            try self.write("// Complex filter input\n");
            try self.writeIndent();
            try self.write("const _tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write(" = ");
            try self.generateExpressionValue(filter.node);
            try self.write(";\n");

            try self.writeIndent();
            try self.write("_ = _tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write(";\n");

            self.indent_level -= 1;
            try self.writeIndent();
            try self.write("}\n");
        }
    }

    /// Generate filter chain (value | filter1 | filter2 | filter3)
    fn generateFilterChain(self: *Self, filter: *nodes.FilterExpr, base_temp: usize) Error!void {
        // Build chain of filters
        var filters = std.ArrayList([]const u8){};
        defer filters.deinit(self.allocator);

        var current: nodes.Expression = nodes.Expression{ .filter = filter };
        while (current == .filter) {
            try filters.append(self.allocator, current.filter.name);
            current = current.filter.node;
        }

        // Now current is the base expression, filters contains filter names in reverse order
        try self.write("{\n");
        self.indent_level += 1;

        // Get initial value
        try self.writeIndent();
        try self.write("var _chain");
        try self.writeFmt("{d}", .{base_temp});
        try self.write(": []const u8 = ");

        if (current == .name) {
            try self.write("ctx.get(\"");
            try self.write(current.name.name);
            try self.write("\") orelse \"\";\n");
        } else if (current == .string_literal) {
            try self.write("\"");
            try self.writeEscapedString(current.string_literal.value);
            try self.write("\";\n");
        } else {
            try self.write("\"\";\n");
        }

        // Apply filters in reverse order (they were collected in reverse)
        var i = filters.items.len;
        while (i > 0) {
            i -= 1;
            const fname = filters.items[i];
            try self.writeIndent();
            try self.write("// Apply filter: ");
            try self.write(fname);
            try self.write("\n");
        }

        // Output final result
        try self.writeIndent();
        try self.write("try writer.writeAll(_chain");
        try self.writeFmt("{d}", .{base_temp});
        try self.write(");\n");

        self.indent_level -= 1;
        try self.writeIndent();
        try self.write("}\n");
    }

    /// Apply a specific filter to a temp variable
    fn applyFilter(self: *Self, filter_name: []const u8, temp_var: usize, args: std.ArrayList(nodes.Expression)) Error!void {
        _ = args; // Would be used for filter arguments

        if (std.mem.eql(u8, filter_name, "upper")) {
            try self.generateUpperFilter(temp_var);
        } else if (std.mem.eql(u8, filter_name, "lower")) {
            try self.generateLowerFilter(temp_var);
        } else if (std.mem.eql(u8, filter_name, "length")) {
            try self.write("try writer.print(\"{d}\", .{_tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write(".len});\n");
        } else if (std.mem.eql(u8, filter_name, "escape") or std.mem.eql(u8, filter_name, "e")) {
            try self.generateEscapeFilter(temp_var);
        } else if (std.mem.eql(u8, filter_name, "trim")) {
            try self.write("try writer.writeAll(std.mem.trim(u8, _tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write(", \" \\t\\n\\r\"));\n");
        } else if (std.mem.eql(u8, filter_name, "first")) {
            try self.write("if (_tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write(".len > 0) try writer.writeByte(_tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write("[0]);\n");
        } else if (std.mem.eql(u8, filter_name, "last")) {
            try self.write("if (_tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write(".len > 0) try writer.writeByte(_tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write("[_tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write(".len - 1]);\n");
        } else if (std.mem.eql(u8, filter_name, "capitalize")) {
            try self.write("if (_tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write(".len > 0) {\n");
            self.indent_level += 1;
            try self.writeIndent();
            try self.write("try writer.writeByte(std.ascii.toUpper(_tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write("[0]));\n");
            try self.writeIndent();
            try self.write("for (_tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write("[1..]) |c| try writer.writeByte(std.ascii.toLower(c));\n");
            self.indent_level -= 1;
            try self.writeIndent();
            try self.write("}\n");
        } else if (std.mem.eql(u8, filter_name, "title")) {
            try self.generateTitleFilter(temp_var);
        } else if (std.mem.eql(u8, filter_name, "reverse")) {
            try self.write("{\n");
            self.indent_level += 1;
            try self.writeIndent();
            try self.write("var i = _tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write(".len;\n");
            try self.writeIndent();
            try self.write("while (i > 0) : (i -= 1) {\n");
            self.indent_level += 1;
            try self.writeIndent();
            try self.write("try writer.writeByte(_tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write("[i - 1]);\n");
            self.indent_level -= 1;
            try self.writeIndent();
            try self.write("}\n");
            self.indent_level -= 1;
            try self.writeIndent();
            try self.write("}\n");
        } else if (std.mem.eql(u8, filter_name, "default") or std.mem.eql(u8, filter_name, "d")) {
            try self.write("if (_tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write(".len > 0) try writer.writeAll(_tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write(") else try writer.writeAll(\"default\");\n");
        } else if (std.mem.eql(u8, filter_name, "safe")) {
            // Safe filter - just output as-is (no escaping)
            try self.write("try writer.writeAll(_tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write(");\n");
        } else if (std.mem.eql(u8, filter_name, "string")) {
            // String filter - output as string
            try self.write("try writer.writeAll(_tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write(");\n");
        } else {
            // Default: just output the value
            try self.write("try writer.writeAll(_tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write("); // filter: ");
            try self.write(filter_name);
            try self.write("\n");
        }
    }

    /// Apply filter to numeric value
    fn applyFilterNumeric(self: *Self, filter_name: []const u8, temp_var: usize) Error!void {
        if (std.mem.eql(u8, filter_name, "abs")) {
            try self.write("try writer.print(\"{d}\", .{if (_tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write(" < 0) -_tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write(" else _tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write("});\n");
        } else {
            try self.write("try writer.print(\"{d}\", .{_tmp");
            try self.writeFmt("{d}", .{temp_var});
            try self.write("}); // filter: ");
            try self.write(filter_name);
            try self.write("\n");
        }
    }

    fn generateTitleFilter(self: *Self, temp_var: usize) Error!void {
        try self.write("{\n");
        self.indent_level += 1;
        try self.writeIndent();
        try self.write("var _capitalize_next = true;\n");
        try self.writeIndent();
        try self.write("for (_tmp");
        try self.writeFmt("{d}", .{temp_var});
        try self.write(") |c| {\n");
        self.indent_level += 1;
        try self.writeIndent();
        try self.write("if (c == ' ' or c == '\\t' or c == '\\n') {\n");
        self.indent_level += 1;
        try self.writeIndent();
        try self.write("try writer.writeByte(c);\n");
        try self.writeIndent();
        try self.write("_capitalize_next = true;\n");
        self.indent_level -= 1;
        try self.writeIndent();
        try self.write("} else if (_capitalize_next) {\n");
        self.indent_level += 1;
        try self.writeIndent();
        try self.write("try writer.writeByte(std.ascii.toUpper(c));\n");
        try self.writeIndent();
        try self.write("_capitalize_next = false;\n");
        self.indent_level -= 1;
        try self.writeIndent();
        try self.write("} else {\n");
        self.indent_level += 1;
        try self.writeIndent();
        try self.write("try writer.writeByte(std.ascii.toLower(c));\n");
        self.indent_level -= 1;
        try self.writeIndent();
        try self.write("}\n");
        self.indent_level -= 1;
        try self.writeIndent();
        try self.write("}\n");
        self.indent_level -= 1;
        try self.writeIndent();
        try self.write("}\n");
    }

    fn generateUpperFilter(self: *Self, temp_var: usize) Error!void {
        try self.write("for (_tmp");
        try self.writeFmt("{d}", .{temp_var});
        try self.write(") |c| try writer.writeByte(std.ascii.toUpper(c));\n");
    }

    fn generateLowerFilter(self: *Self, temp_var: usize) Error!void {
        try self.write("for (_tmp");
        try self.writeFmt("{d}", .{temp_var});
        try self.write(") |c| try writer.writeByte(std.ascii.toLower(c));\n");
    }

    fn generateEscapeFilter(self: *Self, temp_var: usize) Error!void {
        try self.write("for (_tmp");
        try self.writeFmt("{d}", .{temp_var});
        try self.write(") |c| {\n");
        self.indent_level += 1;
        try self.writeIndent();
        try self.write("switch (c) {\n");
        self.indent_level += 1;
        try self.writeIndent();
        try self.write("'&' => try writer.writeAll(\"&amp;\"),\n");
        try self.writeIndent();
        try self.write("'<' => try writer.writeAll(\"&lt;\"),\n");
        try self.writeIndent();
        try self.write("'>' => try writer.writeAll(\"&gt;\"),\n");
        try self.writeIndent();
        try self.write("'\"' => try writer.writeAll(\"&quot;\"),\n");
        try self.writeIndent();
        try self.write("'\\'' => try writer.writeAll(\"&#39;\"),\n");
        try self.writeIndent();
        try self.write("else => try writer.writeByte(c),\n");
        self.indent_level -= 1;
        try self.writeIndent();
        try self.write("}\n");
        self.indent_level -= 1;
        try self.writeIndent();
        try self.write("}\n");
    }

    fn generateGetAttrOutput(self: *Self, attr: *nodes.Getattr) Error!void {
        // Handle loop.index, loop.first, etc.
        if (attr.node == .name) {
            const name = attr.node.name;
            if (std.mem.eql(u8, name.name, "loop")) {
                if (std.mem.eql(u8, attr.attr, "index")) {
                    try self.write("try writer.print(\"{d}\", .{_loop_idx");
                    try self.writeFmt("{d}", .{self.loop_depth});
                    try self.write(" + 1});\n");
                    return;
                } else if (std.mem.eql(u8, attr.attr, "index0")) {
                    try self.write("try writer.print(\"{d}\", .{_loop_idx");
                    try self.writeFmt("{d}", .{self.loop_depth});
                    try self.write("});\n");
                    return;
                } else if (std.mem.eql(u8, attr.attr, "first")) {
                    try self.write("try writer.writeAll(if (_loop_idx");
                    try self.writeFmt("{d}", .{self.loop_depth});
                    try self.write(" == 0) \"true\" else \"false\");\n");
                    return;
                } else if (std.mem.eql(u8, attr.attr, "last")) {
                    try self.write("try writer.writeAll(if (_loop_idx");
                    try self.writeFmt("{d}", .{self.loop_depth});
                    try self.write(" == _loop_len");
                    try self.writeFmt("{d}", .{self.loop_depth});
                    try self.write(" - 1) \"true\" else \"false\");\n");
                    return;
                } else if (std.mem.eql(u8, attr.attr, "length")) {
                    try self.write("try writer.print(\"{d}\", .{_loop_len");
                    try self.writeFmt("{d}", .{self.loop_depth});
                    try self.write("});\n");
                    return;
                } else if (std.mem.eql(u8, attr.attr, "revindex")) {
                    try self.write("try writer.print(\"{d}\", .{_loop_len");
                    try self.writeFmt("{d}", .{self.loop_depth});
                    try self.write(" - _loop_idx");
                    try self.writeFmt("{d}", .{self.loop_depth});
                    try self.write("});\n");
                    return;
                } else if (std.mem.eql(u8, attr.attr, "revindex0")) {
                    try self.write("try writer.print(\"{d}\", .{_loop_len");
                    try self.writeFmt("{d}", .{self.loop_depth});
                    try self.write(" - _loop_idx");
                    try self.writeFmt("{d}", .{self.loop_depth});
                    try self.write(" - 1});\n");
                    return;
                }
            }

            // Generic attribute access - use context helper
            try self.write("if (ctx.getAttr(\"");
            try self.write(name.name);
            try self.write("\", \"");
            try self.write(attr.attr);
            try self.write("\")) |v| try writer.writeAll(v);\n");
        } else if (attr.node == .getattr) {
            // Nested attribute access: obj.attr1.attr2
            try self.write("// Nested attribute access: .");
            try self.write(attr.attr);
            try self.write("\n");
            try self.writeIndent();
            try self.generateGetAttrOutput(attr.node.getattr);
        } else {
            try self.write("// Complex attribute access on expression\n");
        }
    }

    fn generateIf(self: *Self, if_stmt: *nodes.If) Error!void {
        try self.writeIndent();
        try self.write("if (");
        try self.generateCondition(if_stmt.condition);
        try self.write(") {\n");

        self.indent_level += 1;
        for (if_stmt.body.items) |stmt| {
            try self.generateStatement(stmt);
        }
        self.indent_level -= 1;

        // Handle elif
        for (if_stmt.elif_conditions.items, 0..) |elif_cond, i| {
            try self.writeIndent();
            try self.write("} else if (");
            try self.generateCondition(elif_cond);
            try self.write(") {\n");

            self.indent_level += 1;
            for (if_stmt.elif_bodies.items[i].items) |stmt| {
                try self.generateStatement(stmt);
            }
            self.indent_level -= 1;
        }

        if (if_stmt.else_body.items.len > 0) {
            try self.writeIndent();
            try self.write("} else {\n");
            self.indent_level += 1;
            for (if_stmt.else_body.items) |stmt| {
                try self.generateStatement(stmt);
            }
            self.indent_level -= 1;
        }

        try self.writeIndent();
        try self.write("}\n");
    }

    fn generateCondition(self: *Self, expr: nodes.Expression) Error!void {
        switch (expr) {
            .name => |name| {
                try self.write("ctx.get(\"");
                try self.write(name.name);
                try self.write("\") != null");
            },
            .boolean_literal => |lit| {
                try self.write(if (lit.value) "true" else "false");
            },
            .integer_literal => |lit| {
                try self.write(if (lit.value != 0) "true" else "false");
            },
            .string_literal => |lit| {
                try self.write(if (lit.value.len > 0) "true" else "false");
            },
            .bin_expr => |bin| {
                try self.write("(");
                try self.generateCondition(bin.left);
                switch (bin.op) {
                    .EQ => try self.write(" == "),
                    .NE => try self.write(" != "),
                    .LT => try self.write(" < "),
                    .LTEQ => try self.write(" <= "),
                    .GT => try self.write(" > "),
                    .GTEQ => try self.write(" >= "),
                    .AND => try self.write(" and "),
                    .OR => try self.write(" or "),
                    else => try self.write(" == "),
                }
                try self.generateCondition(bin.right);
                try self.write(")");
            },
            .unary_expr => |unary| {
                if (unary.op == .NOT) {
                    try self.write("!");
                }
                try self.generateCondition(unary.node);
            },
            .test_expr => |test_e| {
                // Handle "is" tests
                if (std.mem.eql(u8, test_e.name, "defined")) {
                    try self.generateCondition(test_e.node);
                } else if (std.mem.eql(u8, test_e.name, "undefined")) {
                    try self.write("!");
                    try self.generateCondition(test_e.node);
                } else if (std.mem.eql(u8, test_e.name, "none")) {
                    try self.write("(ctx.get(\"");
                    if (test_e.node == .name) {
                        try self.write(test_e.node.name.name);
                    }
                    try self.write("\") == null)");
                } else if (std.mem.eql(u8, test_e.name, "true")) {
                    try self.generateCondition(test_e.node);
                } else if (std.mem.eql(u8, test_e.name, "false")) {
                    try self.write("!");
                    try self.generateCondition(test_e.node);
                } else if (std.mem.eql(u8, test_e.name, "even")) {
                    try self.write("(");
                    try self.generateCondition(test_e.node);
                    try self.write(" % 2 == 0)");
                } else if (std.mem.eql(u8, test_e.name, "odd")) {
                    try self.write("(");
                    try self.generateCondition(test_e.node);
                    try self.write(" % 2 == 1)");
                } else {
                    try self.write("true /* test: ");
                    try self.write(test_e.name);
                    try self.write(" */");
                }
            },
            else => {
                try self.write("true"); // Default fallback
            },
        }
    }

    fn generateFor(self: *Self, for_stmt: *nodes.For) Error!void {
        self.loop_depth += 1;
        const loop_idx = self.loop_depth;

        // Get the iterable name
        const iter_name = if (for_stmt.iter == .name)
            for_stmt.iter.name.name
        else
            "items";

        // Get loop variable name
        const loop_var = if (for_stmt.target == .name)
            for_stmt.target.name.name
        else
            "_item";

        try self.writeIndent();
        try self.write("if (ctx.getList(\"");
        try self.write(iter_name);
        try self.write("\")) |_items");
        try self.writeFmt("{d}", .{loop_idx});
        try self.write("| {\n");

        self.indent_level += 1;
        try self.writeIndent();
        try self.write("const _loop_len");
        try self.writeFmt("{d}", .{loop_idx});
        try self.write(" = _items");
        try self.writeFmt("{d}", .{loop_idx});
        try self.write(".len;\n");

        // Handle else clause (for empty iteration)
        if (for_stmt.else_body.items.len > 0) {
            try self.writeIndent();
            try self.write("if (_loop_len");
            try self.writeFmt("{d}", .{loop_idx});
            try self.write(" == 0) {\n");
            self.indent_level += 1;
            for (for_stmt.else_body.items) |stmt| {
                try self.generateStatement(stmt);
            }
            self.indent_level -= 1;
            try self.writeIndent();
            try self.write("} else {\n");
            self.indent_level += 1;
        }

        try self.writeIndent();
        try self.write("for (_items");
        try self.writeFmt("{d}", .{loop_idx});
        try self.write(", 0..) |");

        try self.write(loop_var);

        try self.write(", _loop_idx");
        try self.writeFmt("{d}", .{loop_idx});
        try self.write("| {\n");

        // Allow accessing loop variable as context.get(loop_var)
        self.indent_level += 1;
        try self.writeIndent();
        try self.write("_ = ");
        try self.write(loop_var);
        try self.write("; // Use loop var to allow access\n");

        for (for_stmt.body.items) |stmt| {
            try self.generateStatement(stmt);
        }
        self.indent_level -= 1;

        try self.writeIndent();
        try self.write("}\n");

        // Close else block if present
        if (for_stmt.else_body.items.len > 0) {
            self.indent_level -= 1;
            try self.writeIndent();
            try self.write("}\n");
        }

        self.indent_level -= 1;
        try self.writeIndent();
        try self.write("}\n");

        self.loop_depth -= 1;
    }

    // Helper functions
    fn write(self: *Self, str: []const u8) Error!void {
        try self.output.appendSlice(self.allocator, str);
    }

    fn writeFmt(self: *Self, comptime fmt: []const u8, args: anytype) Error!void {
        var buf: [128]u8 = undefined;
        const result = std.fmt.bufPrint(&buf, fmt, args) catch return;
        try self.write(result);
    }

    fn writeIndent(self: *Self) Error!void {
        for (0..self.indent_level) |_| {
            try self.write("    ");
        }
    }

    fn writeEscapedString(self: *Self, str: []const u8) Error!void {
        for (str) |c| {
            switch (c) {
                '"' => try self.write("\\\""),
                '\\' => try self.write("\\\\"),
                '\n' => try self.write("\\n"),
                '\r' => try self.write("\\r"),
                '\t' => try self.write("\\t"),
                else => {
                    const buf = [_]u8{c};
                    try self.write(&buf);
                },
            }
        }
    }
};

/// Compile a template to Zig source code
pub fn compileToZig(allocator: std.mem.Allocator, source: []const u8, name: []const u8) ![]const u8 {
    var compiler = AotCompiler.init(allocator);
    defer compiler.deinit();
    return try compiler.compile(source, name);
}

// Tests
test "AOT compile simple template" {
    const allocator = std.testing.allocator;
    const source = "Hello {{ name }}!";

    const code = try compileToZig(allocator, source, "test");
    defer allocator.free(code);

    // Check that output contains expected patterns
    try std.testing.expect(std.mem.indexOf(u8, code, "pub fn render") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "writeAll") != null);
}

test "AOT compile template with filter" {
    const allocator = std.testing.allocator;
    const source = "{{ name | upper }}";

    const code = try compileToZig(allocator, source, "test_filter");
    defer allocator.free(code);

    try std.testing.expect(std.mem.indexOf(u8, code, "toUpper") != null);
}

test "AOT compile template with loop" {
    const allocator = std.testing.allocator;
    const source = "{% for item in items %}{{ item }}{% endfor %}";

    const code = try compileToZig(allocator, source, "test_loop");
    defer allocator.free(code);

    try std.testing.expect(std.mem.indexOf(u8, code, "for (") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "getList") != null);
}

test "AOT compile template with if" {
    const allocator = std.testing.allocator;
    const source = "{% if show %}visible{% endif %}";

    const code = try compileToZig(allocator, source, "test_if");
    defer allocator.free(code);

    try std.testing.expect(std.mem.indexOf(u8, code, "if (") != null);
}

test "AOT compile template with set statement" {
    const allocator = std.testing.allocator;
    const source = "{% set x = 5 %}{{ x }}";

    const code = try compileToZig(allocator, source, "test_set");
    defer allocator.free(code);

    try std.testing.expect(std.mem.indexOf(u8, code, "_set_x") != null);
}

test "AOT compile template with binary expression" {
    const allocator = std.testing.allocator;
    const source = "{{ 1 + 2 }}";

    const code = try compileToZig(allocator, source, "test_binexpr");
    defer allocator.free(code);

    try std.testing.expect(std.mem.indexOf(u8, code, "_left") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "_right") != null);
}

test "AOT compile template with filter chain" {
    const allocator = std.testing.allocator;
    const source = "{{ name | trim | upper }}";

    const code = try compileToZig(allocator, source, "test_filter_chain");
    defer allocator.free(code);

    // Should contain filter processing
    try std.testing.expect(std.mem.indexOf(u8, code, "filter") != null);
}

test "AOT compile template with attribute access" {
    const allocator = std.testing.allocator;
    const source = "{{ user.name }}";

    const code = try compileToZig(allocator, source, "test_attr");
    defer allocator.free(code);

    try std.testing.expect(std.mem.indexOf(u8, code, "getAttr") != null);
}

test "AOT compile template with loop attributes" {
    const allocator = std.testing.allocator;
    const source = "{% for item in items %}{{ loop.index }}{% endfor %}";

    const code = try compileToZig(allocator, source, "test_loop_attr");
    defer allocator.free(code);

    try std.testing.expect(std.mem.indexOf(u8, code, "_loop_idx") != null);
}
